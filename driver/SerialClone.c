// SerialClone.c
//
// Generated by C DriverWizard 3.2.0 (Build 2485)
// Requires DDK Only
// File created on 9/16/2005
//

#include "pch.h"
#ifdef SERIALCLONE_WMI_TRACE
#include "SerialClone.tmh"
#endif
#define arraysize(p) (sizeof(p)/sizeof((p)[0]))

// global data
SERIALCLONE_DATA g_Data;

DEFINE_GUID(GUID_CLASS_COMPORT, 0x86e0d1e0L, 0x8089, 0x11d0, 0x9c, 0xe4, 0x08,
            0x00, 0x3e, 0x30, 0x1f, 0x73);

///////////////////////////////////////////////////////////////////////////////////////////////////
//  DriverEntry 
//      Installable driver initialization entry point.
//      This entry point is called directly by the I/O system.
//
//  Arguments:
//      IN  DriverObject
//              pointer to the driver object
//
//      IN  RegistryPath
//              pointer to a unicode string representing the path,
//              to driver-specific key in the registry.
//
//  Return Value:
//      STATUS_SUCCESS if successful,
//      STATUS_UNSUCCESSFUL otherwise.
//
NTSTATUS DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    )
{
    NTSTATUS            status = STATUS_SUCCESS;
    ULONG               i;

    SerialCloneDebugPrint(DBG_INIT, DBG_TRACE, __FUNCTION__"++");
    SerialCloneDebugPrint(DBG_INIT, DBG_INFO, "Compiled at %s on %s", __TIME__, __DATE__);

#ifdef DBG
//    DbgBreakPoint();
#endif

#ifdef SERIALCLONE_WMI_TRACE 
    WPP_INIT_TRACING(DriverObject, RegistryPath);
#endif

    RtlZeroMemory(&g_Data, sizeof(SERIALCLONE_DATA));

    // save registry path for wmi
    g_Data.RegistryPath.Length = RegistryPath->Length;
    g_Data.RegistryPath.MaximumLength = RegistryPath->Length + sizeof(UNICODE_NULL);
    g_Data.RegistryPath.Buffer = (PWCHAR)ExAllocatePoolWithTag(
                                            PagedPool,
                                            g_Data.RegistryPath.MaximumLength,
                                            SERIALCLONE_POOL_TAG
                                            );

    if (g_Data.RegistryPath.Buffer == NULL)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;

        SerialCloneDebugPrint(DBG_INIT, DBG_ERR, __FUNCTION__": Failed to allocate memory for RegistryPath");

        return status;
    }

    RtlCopyUnicodeString(&g_Data.RegistryPath, RegistryPath);

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; ++i)
    {
        DriverObject->MajorFunction[i] = SerialClonePassThrough;
    }
    // setup our dispatch function table in the driver object
    DriverObject->MajorFunction[IRP_MJ_PNP] = SerialClonePnpDispatch;
    DriverObject->MajorFunction[IRP_MJ_POWER] = SerialClonePowerDispatch;
    DriverObject->MajorFunction[IRP_MJ_CREATE] = SerialCloneCreateDispatch;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = SerialCloneCloseDispatch;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = SerialCloneDeviceIoControlDispatch;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = SerialCloneInternalDeviceIoControlDispatch;
    DriverObject->MajorFunction[IRP_MJ_READ] = SerialCloneReadDispatch;
    DriverObject->MajorFunction[IRP_MJ_WRITE] = SerialCloneWriteDispatch;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = SerialCloneCleanupDispatch;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = SerialCloneSystemControlDispatch;
    DriverObject->DriverExtension->AddDevice = SerialCloneAddDevice;
    DriverObject->DriverUnload = SerialCloneUnload;
    SerialCloneDebugPrint(DBG_INIT, DBG_TRACE, __FUNCTION__"--. STATUS %x", status);
    return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  SerialCloneAddDevice 
//      The PnP manager has enumerated a device with hardware ID that matches
//      the ID our driver's INF exposed.
//
//      We need to:
//          Determine if we need to be in the driver stack for the device.
//          Create a function device object to attach to the stack
//          Initialize that device object
//          Return status success.
//
//      We must NOT send ANY non-pnp IRPS to the given driver
//      stack, UNTIL we have received an IRP_MN_START_DEVICE.
//
//  Arguments:
//      IN  DeviceObject
//              pointer to a device object.
//
//      IN  PhysicalDeviceObject
//              pointer to a device object created by the
//              underlying bus driver.
//
//  Return Value:
//      STATUS_SUCCESS
//
NTSTATUS SerialCloneAddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    )
{
    NTSTATUS                            status;

    PDEVICE_OBJECT                      fdeviceObject;
    PDEVICE_OBJECT                      cdeviceObject;

    PSERIALCLONE_DEVICE_EXTENSION		fdeviceExtension;
    PSERIALCLONE_DEVICE_EXTENSION		cdeviceExtension;
    ULONG                               deviceType;
    UNICODE_STRING                      ntName;
    UNICODE_STRING                      ntDeviceName;
    UNICODE_STRING                      instanceString;
    WCHAR                               instanceStringBuffer[20];

	WCHAR name[64];
	ANSI_STRING							dbgString;
	char *								buffptr;
    SerialCloneDebugPrint(DBG_INIT, DBG_TRACE, __FUNCTION__"++, PDO %p", PhysicalDeviceObject);

    if (!IoIsWdmVersionAvailable(1, 0x20))
    {
        // on Win2k for storage stack we need to copy
        // DeviceType from the top of the stack device object,
        // otherwise OS will bugcheck
        fdeviceObject = IoGetAttachedDeviceReference(PhysicalDeviceObject);
        deviceType = fdeviceObject->DeviceType;
        ObDereferenceObject(fdeviceObject);
    }
    else
    {
        deviceType = FILE_DEVICE_UNKNOWN;
    }
    //**************** create our filter device object *************************
    status = IoCreateDevice(
                DriverObject,
                sizeof(SERIALCLONE_DEVICE_EXTENSION),
                NULL,
                deviceType,
                FILE_DEVICE_SECURE_OPEN,
                FALSE,
                &fdeviceObject
                );

    if (!NT_SUCCESS(status))
    {
        SerialCloneDebugPrint(DBG_INIT, DBG_ERR, __FUNCTION__"--, IoCreateDevice returned STATUS %x", status);
        return status;
    }
    SerialCloneDebugPrint(DBG_INIT, DBG_INFO, __FUNCTION__": Created FiDO %p", fdeviceObject);
    // Initialize the device extension.
    fdeviceExtension = (PSERIALCLONE_DEVICE_EXTENSION)fdeviceObject->DeviceExtension;
    // Zero the memory
    RtlZeroMemory(fdeviceExtension, sizeof(SERIALCLONE_DEVICE_EXTENSION));
    
	fdeviceExtension->TypeFlag = ISFILTER;
    // save the PDO pointer
	fdeviceExtension->PhysicalDeviceObject = PhysicalDeviceObject;
    // save our device object
    fdeviceExtension->FDeviceObject = fdeviceObject;
    // set RemoveCount to 1. Transition to zero
    // means IRP_MN_REMOVE_DEVICE was received
    fdeviceExtension->RemoveCount = 1 ;
	fdeviceExtension->OpenHandleCount=0;

    // Initialize Remove event
    KeInitializeEvent(&fdeviceExtension->RemoveEvent, NotificationEvent, FALSE);
    fdeviceExtension->PnpState = PnpStateNotStarted;
    fdeviceExtension->PreviousPnpState = PnpStateNotStarted;
	fdeviceExtension->OpenState=OpenStateClosed;
    // Attach our device to the device stack and get the device object to 
    // which we send down IRPs to.
    fdeviceExtension->LowerDeviceObject = IoAttachDeviceToDeviceStack(fdeviceObject, PhysicalDeviceObject);
    if (fdeviceExtension->LowerDeviceObject == NULL) 
    {
        SerialCloneDebugPrint(DBG_INIT, DBG_ERR, __FUNCTION__": IoAttachDeviceToDeviceStack failed!");
        IoDeleteDevice(fdeviceObject);
        return STATUS_DEVICE_REMOVED;
    }
    // Initialize the device object flags
    fdeviceObject->Flags = 
        fdeviceExtension->LowerDeviceObject->Flags & (DO_BUFFERED_IO | DO_DIRECT_IO | DO_POWER_PAGABLE);

    fdeviceObject->DeviceType = fdeviceExtension->LowerDeviceObject->DeviceType;
    fdeviceObject->Characteristics = fdeviceExtension->LowerDeviceObject->Characteristics;

	// allocate lookaside list

	ExInitializeNPagedLookasideList(&fdeviceExtension->LookasideBuffer,NULL,NULL,0,
		sizeof(SERIALCLONE_IRP_STATUS),SERIALCLONE_POOL_TAG,0);

	// initialize the IRP lists
	InitializeListHead(&fdeviceExtension->Reads);
	ASSERT(IsListEmpty(&fdeviceExtension->Reads));
	KeInitializeSpinLock(&fdeviceExtension->ListLock);

	// Allocate our read buffer
    buffptr = (PCHAR)ExAllocatePoolWithTag(NonPagedPool ,8192 , SERIALCLONE_POOL_TAG);

    if (buffptr == NULL) 
    {
        SerialCloneDebugPrint(DBG_INIT, DBG_ERR, __FUNCTION__": Insufficient memory");
        ExDeleteNPagedLookasideList(&fdeviceExtension->LookasideBuffer);
		IoDeleteDevice(fdeviceObject);
        return STATUS_DEVICE_REMOVED;
    }
	SCFifoInit(&fdeviceExtension->ReadBuffer, buffptr, 8192);
	KeInitializeSpinLock(&fdeviceExtension->ReadBuffer.FifoLock);

    //**************** create our clone device object *************************
    // create device object name 

    ntName.Length = 0;
    ntName.MaximumLength = sizeof(L"\\Device\\SerialCloneDevice") + 20;
    ntName.Buffer = (PWCHAR)ExAllocatePoolWithTag(PagedPool, ntName.MaximumLength, SERIALCLONE_POOL_TAG);
    if (ntName.Buffer == NULL)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        IoDeleteDevice(fdeviceObject);
        SerialCloneDebugPrint(DBG_INIT, DBG_ERR, __FUNCTION__"--. STATUS %x", status);
        return status;
    }

    RtlZeroMemory(ntName.Buffer, ntName.MaximumLength);
    RtlAppendUnicodeToString(&ntName, L"\\Device\\SerialCloneDevice");

    instanceString.Length = 0;
    instanceString.MaximumLength = sizeof(instanceStringBuffer);
    instanceString.Buffer = instanceStringBuffer;
    RtlIntegerToUnicodeString(5, 10, &instanceString);
    RtlAppendUnicodeStringToString(&ntName, &instanceString);

    status = IoCreateDevice(
                DriverObject,
                sizeof(SERIALCLONE_DEVICE_EXTENSION),
                &ntName,
                FILE_DEVICE_SERIAL_PORT,
                FILE_DEVICE_SECURE_OPEN,
                FALSE,
                &cdeviceObject
                );

    if (!NT_SUCCESS(status))
    {
        SerialCloneDebugPrint(DBG_INIT, DBG_ERR, __FUNCTION__"--, IoCreateDevice returned STATUS %x", status);
        IoDeleteDevice(fdeviceObject);
		return status;
    }
	//status = RtlUnicodeStringToAnsiString(&dbgString,&ntName,TRUE);
	if(NT_SUCCESS(status))
		SerialCloneDebugPrint(DBG_INIT, DBG_INFO, __FUNCTION__": Created ClDO::%p ", cdeviceObject);
    // Initialize the device extension.
    cdeviceExtension = (PSERIALCLONE_DEVICE_EXTENSION)cdeviceObject->DeviceExtension;
    // Zero the memory
    RtlZeroMemory(cdeviceExtension, sizeof(SERIALCLONE_DEVICE_EXTENSION));
    // save the PDO pointer

    cdeviceExtension->TypeFlag = ISCLONE;
	cdeviceExtension->OpenHandleCount=0;
    cdeviceExtension->PhysicalDeviceObject = PhysicalDeviceObject;
    // save our device object
    cdeviceExtension->CDeviceObject = cdeviceObject;
    cdeviceExtension->FDeviceObject = fdeviceObject;
    fdeviceExtension->CDeviceObject = cdeviceObject;
   
	// set RemoveCount to 1. Transition to zero
    // means IRP_MN_REMOVE_DEVICE was received
    cdeviceExtension->RemoveCount = 1 ;
    // Initialize Remove event
    KeInitializeEvent(&cdeviceExtension->RemoveEvent, NotificationEvent, FALSE);
    cdeviceExtension->PnpState = PnpStateNotStarted;
    cdeviceExtension->PreviousPnpState = PnpStateNotStarted;
	cdeviceExtension->OpenState=OpenStateClosed;
	fdeviceExtension->ntDeviceName=ntName; 
	cdeviceExtension->ntDeviceName=ntName; 

    // Initialize the device object flags
    cdeviceObject->Flags = fdeviceObject->Flags;

    cdeviceExtension->LowerDeviceObject = fdeviceExtension->LowerDeviceObject;
	//= IoAttachDeviceToDeviceStack(cdeviceObject, PhysicalDeviceObject);
    //if (cdeviceExtension->LowerDeviceObject == NULL) 
    //{
    //    SerialCloneDebugPrint(DBG_INIT, DBG_ERR, __FUNCTION__": IoAttachDeviceToDeviceStack failed!");
    //    IoDeleteDevice(cdeviceObject);
    //    return STATUS_DEVICE_REMOVED;
   // }

    
	
	cdeviceObject->DeviceType = FILE_DEVICE_SERIAL_PORT;
    cdeviceObject->Characteristics = fdeviceObject->Characteristics;

	cdeviceExtension->Extension= fdeviceExtension;
	fdeviceExtension->Extension= cdeviceExtension;
	// Allocate our read buffer
    buffptr = (PCHAR)ExAllocatePoolWithTag(NonPagedPool ,8192 , SERIALCLONE_POOL_TAG);

    if (buffptr == NULL) 
    {
        SerialCloneDebugPrint(DBG_INIT, DBG_ERR, __FUNCTION__": Insufficient memory");
		IoDeleteDevice(fdeviceObject);
        return STATUS_DEVICE_REMOVED;
    }
	
	SCFifoInit(&cdeviceExtension->ReadBuffer, buffptr, 8192);
	KeInitializeSpinLock(&cdeviceExtension->ReadBuffer.FifoLock);
	
	//************************************************

	
	status = STATUS_SUCCESS;
    // We are all done, so we need to clear the
    // DO_DEVICE_INITIALIZING flag.  This must be our
    // last action in AddDevice
	cdeviceObject->StackSize = fdeviceObject->StackSize;
    fdeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    cdeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    SerialCloneDebugPrint(DBG_INIT, DBG_TRACE, __FUNCTION__"--, STATUS %x", status);

    return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  SerialCloneUnload
//      Driver Unload routine.
//
//  Arguments:
//      IN  DriverObject
//              pointer to the driver object
//
//  Return Value:
//      none
//
VOID SerialCloneUnload(
    IN  PDRIVER_OBJECT  DriverObject
    )
{
    SerialCloneDebugPrint(DBG_UNLOAD, DBG_TRACE, __FUNCTION__"++");

    ASSERT(DriverObject->DeviceObject == NULL);

    // release memory block allocated for registry path
    if (g_Data.RegistryPath.Buffer != NULL)
    {
        ExFreePool(g_Data.RegistryPath.Buffer);
        g_Data.RegistryPath.Buffer = NULL;
    }

    SerialCloneDebugPrint(DBG_UNLOAD, DBG_TRACE, __FUNCTION__"--");

#ifdef SERIALCLONE_WMI_TRACE
    WPP_CLEANUP(DriverObject);
#endif

    return;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  SerialClonePassThrough
//      Default IRP Dispatch routine.
//
//  Arguments:
//      IN  DeviceObject
//              pointer to the device object for our device
//
//      IN  Irp
//              the IRP
//
//  Return Value:
//      NT status code.
//
NTSTATUS __stdcall SerialClonePassThrough(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
{
    PSERIALCLONE_DEVICE_EXTENSION    deviceExtension;
    NTSTATUS                        status;

    SerialCloneDebugPrint(DBG_GENERAL, DBG_TRACE, __FUNCTION__"++. IRP %p", Irp);

    deviceExtension = (PSERIALCLONE_DEVICE_EXTENSION)DeviceObject->DeviceExtension;

    if (!SerialCloneAcquireRemoveLock(deviceExtension))
    {
        status = STATUS_DELETE_PENDING;

        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);

        SerialCloneDebugPrint(DBG_GENERAL, DBG_WARN, __FUNCTION__"--. IRP %p STATUS %x", Irp, status);

        return status;
    }

    IoSkipCurrentIrpStackLocation(Irp);
    status = IoCallDriver(deviceExtension->LowerDeviceObject, Irp);

    SerialCloneReleaseRemoveLock(deviceExtension);

    SerialCloneDebugPrint(DBG_GENERAL, DBG_TRACE, __FUNCTION__"--. IRP %p STATUS %x", Irp, status);

    return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  SerialClonePnpDispatch
//      Dispatch routine to handle PnP requests
//
//  Arguments:
//      IN  DeviceObject
//              pointer to our device object
//
//      IN  Irp
//              pointer to the PnP IRP
//
//  Return Value:
//      NT status code
//
NTSTATUS SerialClonePnpDispatch(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PSERIALCLONE_DEVICE_EXTENSION    deviceExtension;
    deviceExtension = (PSERIALCLONE_DEVICE_EXTENSION)DeviceObject->DeviceExtension;

    if(deviceExtension->TypeFlag == ISCLONE)
		return(ClonePnpDispatch(DeviceObject,Irp));
	else if(deviceExtension->TypeFlag == ISFILTER)
		return(FilterPnpDispatch(DeviceObject,Irp));
	else
		return STATUS_NOT_IMPLEMENTED;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  SerialClonePowerDispatch 
//      Dispatch routine for IRPs of IRP_MJ_POWER type
//
//  Arguments:
//      IN  DeviceObject
//              Device object for our driver
//
//      IN  Irp
//              The power IRP to handle
//
//  Return Value:
//      STATUS_SUCCESS on success
//      STATUS_UNSUCESSFUL otherwise
//
NTSTATUS SerialClonePowerDispatch(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
{
    PSERIALCLONE_DEVICE_EXTENSION    deviceExtension;
    deviceExtension = (PSERIALCLONE_DEVICE_EXTENSION)DeviceObject->DeviceExtension;

    if(deviceExtension->TypeFlag == ISCLONE)
		return(ClonePowerDispatch(DeviceObject,Irp));
	else if(deviceExtension->TypeFlag == ISFILTER)
		return(FilterPowerDispatch(DeviceObject,Irp));
	else
		return STATUS_NOT_IMPLEMENTED;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  SerialCloneSystemControlDispatch
//      Dispatch routine to handle IRP_MJ_SYSTEM_CONTROL
//
//  Arguments:
//      IN  DeviceObject
//              pointer to our device object
//
//      IN  Irp
//              pointer to the IRP_MJ_SYSTEM_CONTROL IRP
//
//  Return Value:
//      NT status code
//
NTSTATUS SerialCloneSystemControlDispatch(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
{
    PSERIALCLONE_DEVICE_EXTENSION    deviceExtension;
    NTSTATUS                        status;

    deviceExtension = (PSERIALCLONE_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    if(deviceExtension->TypeFlag == ISCLONE)
		return(CloneSystemControlDispatch(DeviceObject,Irp));
	else if(deviceExtension->TypeFlag == ISFILTER)
		return(FilterSystemControlDispatch(DeviceObject,Irp));
	else
		return STATUS_NOT_IMPLEMENTED;

}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  SerialCloneCreateDispatch
//      Dispatch routine to handle IRP_MJ_CREATE
//
//  Arguments:
//      IN  DeviceObject
//              pointer to our device object
//
//      IN  Irp
//              pointer to the IRP_MJ_CREATE IRP
//
//  Return Value:
//      NT status code
//

NTSTATUS SerialCloneCreateDispatch(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
{
    PSERIALCLONE_DEVICE_EXTENSION    deviceExtension;
    PSERIALCLONE_DEVICE_EXTENSION	fdeviceExtension;
	NTSTATUS                        status;
    deviceExtension = (PSERIALCLONE_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
        // Make sure we can accept IRPs
	fdeviceExtension= (deviceExtension->TypeFlag == ISCLONE) ? deviceExtension->Extension:deviceExtension;

    if (!SerialCloneAcquireRemoveLock(deviceExtension))
    {
        status = STATUS_DELETE_PENDING;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        SerialCloneDebugPrint(DBG_GENERAL, DBG_WARN, __FUNCTION__"--. IRP %p STATUS %x", Irp, status);
        return status;
    }

	// check if device was already opened
	// first us
    if (InterlockedIncrement(&deviceExtension->OpenHandleCount) != 1)
    {
        status = STATUS_ACCESS_DENIED;
        InterlockedDecrement(&deviceExtension->OpenHandleCount);
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        SerialCloneReleaseRemoveLock(deviceExtension);
        SerialCloneDebugPrint(DBG_CREATECLOSE, DBG_WARN, __FUNCTION__"$$--. IRP %p, STATUS %x", Irp, status);
        return status;
    }
    // then see if other has open it
	if(deviceExtension->Extension->OpenHandleCount !=0)
	{
		// the other device has it open
		// return success	
		SerialCloneReleaseRemoveLock(deviceExtension);
		SerialCloneDebugPrint(DBG_GENERAL, DBG_TRACE, __FUNCTION__"--. IRP %p STATUS %x", Irp, STATUS_SUCCESS);
	    return SucceedRequest(DeviceObject,Irp);
	}
    if (!SerialCloneAcquireRemoveLock(fdeviceExtension))
    {
        //status = STATUS_DELETE_PENDING;
        //Irp->IoStatus.Status = status;
        //IoCompleteRequest (Irp, IO_NO_INCREMENT);
        SerialCloneDebugPrint(DBG_GENERAL, DBG_WARN, __FUNCTION__"--. IRP %p" , Irp);
        //return status;
    }
	// No we must open it...
	if(deviceExtension->TypeFlag == ISCLONE)
		status = IoForwardIrpSynchronously(fdeviceExtension->LowerDeviceObject, Irp);
	else
		status = SerialCloneSubmitIrpSync(deviceExtension->LowerDeviceObject, Irp);
    if (!NT_SUCCESS(status)) 
	{
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        SerialCloneReleaseRemoveLock(deviceExtension);
        SerialCloneDebugPrint(DBG_CREATECLOSE, DBG_WARN, __FUNCTION__"$$--. IRP %p, STATUS %x", Irp, status);
		return status;		
	}
	// Mark Owner
	deviceExtension->Owner = deviceExtension->TypeFlag;
	deviceExtension->Extension->Owner = deviceExtension->TypeFlag;
	deviceExtension->OpenState=OpenStateCreate;

    SerialCloneReleaseRemoveLock(deviceExtension);
    SerialCloneDebugPrint(DBG_GENERAL, DBG_TRACE, __FUNCTION__"--. IRP %p STATUS %x", Irp, status);
    return status;

}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  SerialCloneCloseDispatch
//      Dispatch routine to handle IRP_MJ_CLOSE
//
//  Arguments:
//      IN  DeviceObject
//              pointer to our device object
//
//      IN  Irp
//              pointer to the IRP_MJ_CLOSE IRP
//
//  Return Value:
//      NT status code
//
NTSTATUS SerialCloneCloseDispatch(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
{
    PSERIALCLONE_DEVICE_EXTENSION    deviceExtension;
    NTSTATUS                        status;

    SerialCloneDebugPrint(DBG_GENERAL, DBG_TRACE, __FUNCTION__"++. IRP %p", Irp);
    deviceExtension = (PSERIALCLONE_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    
    // Make sure we can accept IRPs
    if (!SerialCloneAcquireRemoveLock(deviceExtension))
    {
        status = STATUS_DELETE_PENDING;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        SerialCloneDebugPrint(DBG_GENERAL, DBG_WARN, __FUNCTION__"--. IRP %p STATUS %x", Irp, status);
        return status;
    }
	if(deviceExtension->OpenHandleCount!=1)
	{
		// we didn't do an open!
        status = STATUS_ACCESS_DENIED;
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        SerialCloneReleaseRemoveLock(deviceExtension);
        SerialCloneDebugPrint(DBG_CREATECLOSE, DBG_WARN, __FUNCTION__"$$--. IRP %p, STATUS %x", Irp, status);
        return status;
	}
	// decrement our count
    InterlockedDecrement(&deviceExtension->OpenHandleCount);
	if((deviceExtension->Extension->OpenHandleCount==0)&&(deviceExtension->Owner == deviceExtension->TypeFlag))
	{
		// We are the only one open, issue the close
	    IoSkipCurrentIrpStackLocation(Irp);
	    status = IoCallDriver(deviceExtension->LowerDeviceObject, Irp);
	}
	else
	{
		if(deviceExtension->Owner == deviceExtension->TypeFlag)
		{
			// migrate owner
			deviceExtension->Owner = deviceExtension->Extension->TypeFlag;
			deviceExtension->Extension->Owner = deviceExtension->Extension->TypeFlag;
			status = STATUS_SUCCESS;
			Irp->IoStatus.Status = status;
			Irp->IoStatus.Information = 0;
			IoCompleteRequest(Irp, IO_NO_INCREMENT);

		}
		else
		{
			status = STATUS_ACCESS_DENIED;
			Irp->IoStatus.Status = status;
			Irp->IoStatus.Information = 0;
			IoCompleteRequest(Irp, IO_NO_INCREMENT);
		}
	}
	SerialCloneReleaseRemoveLock(deviceExtension);
	SerialCloneDebugPrint(DBG_GENERAL, DBG_TRACE, __FUNCTION__"--. IRP %p STATUS %x", Irp, status);

    return status;


}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  SerialCloneCleanupDispatch
//      Dispatch routine to handle IRP_MJ_CLEANUP
//
//  Arguments:
//      IN  DeviceObject
//              pointer to our device object
//
//      IN  Irp
//              pointer to the IRP_MJ_CLEANUP IRP
//
//  Return Value:
//      NT status code
//
NTSTATUS SerialCloneCleanupDispatch(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
{
    PSERIALCLONE_DEVICE_EXTENSION    deviceExtension;
    NTSTATUS                        status;

    deviceExtension = (PSERIALCLONE_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
       if(deviceExtension->TypeFlag == ISCLONE)
		return(CloneCleanupDispatch(DeviceObject,Irp));
	else if(deviceExtension->TypeFlag == ISFILTER)
		return(FilterCleanupDispatch(DeviceObject,Irp));
	else
		return STATUS_NOT_IMPLEMENTED;

}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  SerialCloneReadDispatch
//      Dispatch routine to handle IRP_MJ_READ
//
//  Arguments:
//      IN  DeviceObject
//              pointer to our device object
//
//      IN  Irp
//              pointer to the IRP_MJ_READ IRP
//
//  Return Value:
//      NT status code
//

NTSTATUS SCReadComplete( IN  PDEVICE_OBJECT  DeviceObject,IN  PIRP  Irp,PSERIALCLONE_DEVICE_EXTENSION pdx)
{
	NTSTATUS status;
	NTSTATUS fifostatus;
    PIO_STACK_LOCATION    irpStack;
	PSERIALCLONE_DEVICE_EXTENSION filterExtension;
	PSERIALCLONE_DEVICE_EXTENSION odx;
	ULONG bufsiz,actsiz;

	int cc=2;
	PLIST_ENTRY plist;
	PSERIALCLONE_IRP_STATUS pIrpInfo;

	SerialCloneDebugPrint(DBG_GENERAL, DBG_TRACE, __FUNCTION__"++. IRP %p ", Irp);
    // Get our current IRP stack location
    irpStack = IoGetCurrentIrpStackLocation(Irp);

	if(Irp->PendingReturned)
		IoMarkIrpPending(Irp);

	if(pdx->TypeFlag == ISCLONE)
		filterExtension = pdx->Extension;
	else
		filterExtension= pdx;

	odx = pdx;
	bufsiz = irpStack->Parameters.Read.Length;


	if(!IsListEmpty(&filterExtension->Reads))
	{
		char * tmp ;
		// for each device filter and clone 
		while(cc--)
		{
			//char tbuff[200];
			//size_t strnglen;
	
			// copy data into fifo
			if(odx->OpenState=OpenStateReading)
			{
				if(odx->FDeviceObject->Flags & DO_BUFFERED_IO)
				{
					tmp = Irp->AssociatedIrp.SystemBuffer;
					bufsiz = irpStack->Parameters.Read.Length;
					//************ Fifo Lock ******************
					KeAcquireSpinLock(&odx->ReadBuffer.FifoLock,&odx->ReadBuffer.SpunIRQ);
					SerialCloneDebugPrint(DBG_GENERAL, DBG_TRACE, __FUNCTION__"FifoLock IN IRP %p ", Irp);
					fifostatus = SCFifoWrite(&odx->ReadBuffer,  tmp,  bufsiz);
					SerialCloneDebugPrint(DBG_GENERAL, DBG_TRACE, __FUNCTION__"FifoLock OUT IRP %p ", Irp);

					KeReleaseSpinLock(&odx->ReadBuffer.FifoLock,odx->ReadBuffer.SpunIRQ);
					//****************** end lock *******************

					//RtlCopyMemory(tbuff,tmp,197);
					//tbuff[197]=0;
					//tbuff[198]=0;
					//SerialCloneDebugPrint(DBG_GENERAL, DBG_TRACE, "Buffer:: %s",tbuff);

				}
				else if(pdx->FDeviceObject->Flags & DO_DIRECT_IO)
				{


				}
			}
			odx=odx->Extension;
		}
		//************ list lock **********************
		//KeAcquireSpinLock(&filterExtension->ListLock,&filterExtension->SpunListIRQ);
		SerialCloneDebugPrint(DBG_GENERAL, DBG_TRACE,__FUNCTION__"ListLock IN IRP %p ", Irp);
		// get back the origional size
		plist = 	RemoveHeadList(&filterExtension->Reads);	
		//************ release list lock ************************
		SerialCloneDebugPrint(DBG_GENERAL, DBG_TRACE, __FUNCTION__"ListOut OUT IRP %p ", Irp);

		//KeReleaseSpinLock(&filterExtension->ListLock,filterExtension->SpunListIRQ);
		
		pIrpInfo = CONTAINING_RECORD(plist,SERIALCLONE_IRP_STATUS,link);
		if(pIrpInfo->Irp != Irp)
		{
			SerialCloneDebugPrint(DBG_GENERAL, DBG_WARN, __FUNCTION__"Read out of sync. IRP:%p Fifo IRP:%p", Irp, pIrpInfo->Irp);
		}
		//************ Fifo Lock ******************
		KeAcquireSpinLock(&odx->ReadBuffer.FifoLock,&odx->ReadBuffer.SpunIRQ);
		bufsiz = (pIrpInfo->RequestedSize<pdx->ReadBuffer.Size) ? pIrpInfo->RequestedSize:pdx->ReadBuffer.Size;
		fifostatus = SCFifoRead(&pdx->ReadBuffer,  Irp->AssociatedIrp.SystemBuffer, bufsiz,&actsiz);
		KeReleaseSpinLock(&odx->ReadBuffer.FifoLock,odx->ReadBuffer.SpunIRQ);
		//****************** end lock *******************

		irpStack->Parameters.Read.Length=actsiz;
		Irp->IoStatus.Information= actsiz;
		ExFreePool(pIrpInfo);
	}

	SerialCloneReleaseRemoveLock(pdx);
	SerialCloneDebugPrint(DBG_GENERAL, DBG_TRACE, __FUNCTION__"--. IRP %p STATUS %x", Irp, STATUS_SUCCESS);
	return STATUS_SUCCESS;
}
NTSTATUS SerialCloneReadDispatch(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
{
    PSERIALCLONE_DEVICE_EXTENSION		deviceExtension;
    PSERIALCLONE_DEVICE_EXTENSION		filterExtension;
	NTSTATUS							status;
	PSERIALCLONE_IRP_STATUS				pIrpInfo;
    PIO_STACK_LOCATION					irpStack;

    SerialCloneDebugPrint(DBG_GENERAL, DBG_TRACE, __FUNCTION__"++. IRP %p", Irp);

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    // Get our device extension from the device object
    deviceExtension = (PSERIALCLONE_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    // Make sure we can accept IRPs
    if (!SerialCloneAcquireRemoveLock(deviceExtension))
    {
        status = STATUS_DELETE_PENDING;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        SerialCloneDebugPrint(DBG_GENERAL, DBG_WARN, __FUNCTION__"--. IRP %p STATUS %x", Irp, status);
        return status;
    }
	deviceExtension->OpenState=OpenStateReading;

	// we need the extension for the filter to get the lists..
	if(deviceExtension->TypeFlag == ISCLONE)
		filterExtension = deviceExtension->Extension;
	else
		filterExtension= deviceExtension;

    
	// 1) allocate an IRP info struct

	pIrpInfo = (PSERIALCLONE_IRP_STATUS)ExAllocateFromNPagedLookasideList(&filterExtension->LookasideBuffer);
	if(pIrpInfo==NULL)
	{
        status = STATUS_INSUFFICIENT_RESOURCES;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        SerialCloneDebugPrint(DBG_GENERAL, DBG_WARN, __FUNCTION__"--. IRP %p STATUS %x", Irp, status);
        return status;
	}
	pIrpInfo->Irp=Irp;
	pIrpInfo->RequestedSize = irpStack->Parameters.Read.Length;
	pIrpInfo->Status=0;
	//
	//		check the buffer for this device for the request data 
	//			if the buffer has enough data to satify read

	//************ Fifo Lock ******************
	KeAcquireSpinLock(&deviceExtension->ReadBuffer.FifoLock,&deviceExtension->ReadBuffer.SpunIRQ);
	SerialCloneDebugPrint(DBG_GENERAL, DBG_TRACE, __FUNCTION__"Fifolock IN IRP %p ", Irp);

	if(deviceExtension->ReadBuffer.Size>pIrpInfo->RequestedSize)
	{
		//				Copy the data
		ULONG readsz;
		SCFifoRead(&deviceExtension->ReadBuffer,Irp->AssociatedIrp.SystemBuffer,pIrpInfo->RequestedSize,&readsz);
		KeReleaseSpinLock(&deviceExtension->ReadBuffer.FifoLock,deviceExtension->ReadBuffer.SpunIRQ);
		SerialCloneDebugPrint(DBG_GENERAL, DBG_TRACE, __FUNCTION__"Fifolock OUT IRP %p ", Irp);

		Irp->IoStatus.Status = STATUS_SUCCESS;
		Irp->IoStatus.Information= pIrpInfo->RequestedSize;
		IoCompleteRequest(Irp, IO_NO_INCREMENT);
	    SerialCloneDebugPrint(DBG_GENERAL, DBG_TRACE, __FUNCTION__"--.Fifo Completed! IRP %p STATUS %x", Irp, STATUS_SUCCESS);
	
		return STATUS_SUCCESS;
	}
	
	//			else adjust the request size in the IRP
	irpStack->Parameters.Read.Length -=deviceExtension->ReadBuffer.Size;
	SerialCloneDebugPrint(DBG_GENERAL, DBG_TRACE, __FUNCTION__"Fifolock OUT IRP %p ", Irp);
	KeReleaseSpinLock(&deviceExtension->ReadBuffer.FifoLock,deviceExtension->ReadBuffer.SpunIRQ);
	//****************** end lock *******************

	// 3) check pending list - list of outstanding IRP's
	//		Get amount requested in pending
	//		if amount greater than current request size
	
	//****************** get list lock **************************
	if(deviceExtension->TypeFlag==ISCLONE)
	{
		SerialCloneDebugPrint(DBG_GENERAL, DBG_TRACE, __FUNCTION__" Clone attempting Listlock IRP %p ", Irp);
	}

	//KeAcquireSpinLock(&filterExtension->ListLock,&filterExtension->SpunListIRQ);
	SerialCloneDebugPrint(DBG_GENERAL, DBG_TRACE, __FUNCTION__" Listlock IN IRP %p ", Irp);

	if(GetPendingSize(&filterExtension->Reads) >= irpStack->Parameters.Read.Length)	
	{
	//	always issue the irp 1 byte min.
		SerialCloneDebugPrint(DBG_GENERAL, DBG_TRACE, __FUNCTION__" Requesting min 1 byte read IRP %p ", Irp);
		pIrpInfo->Status = READWAITING;
		irpStack->Parameters.Read.Length=1;
	}
	else
	{
	//		else adjust request size
		irpStack->Parameters.Read.Length-= GetPendingSize(&filterExtension->Reads);
		SerialCloneDebugPrint(DBG_GENERAL, DBG_TRACE, __FUNCTION__" Requesting %d bytes IRP %p ",irpStack->Parameters.Read.Length, Irp);

	}
		//
	// 4)send read request along to next lower device
	pIrpInfo->Status = READPENDING;
	InsertTailList(&filterExtension->Reads,&pIrpInfo->link);		
	SerialCloneDebugPrint(DBG_GENERAL, DBG_TRACE, __FUNCTION__"Listlock OUT IRP %p ", Irp);
	//KeReleaseSpinLock(&filterExtension->ListLock,filterExtension->SpunListIRQ);
	//******************* release list lock ******************

	IoCopyCurrentIrpStackLocationToNext(Irp); 
	IoSetCompletionRoutine(Irp,(PIO_COMPLETION_ROUTINE)SCReadComplete,deviceExtension,TRUE,TRUE,TRUE);
	status = IoCallDriver(filterExtension->LowerDeviceObject, Irp);
		
    
	//SerialCloneReleaseRemoveLock(deviceExtension);
    SerialCloneDebugPrint(DBG_GENERAL, DBG_TRACE, __FUNCTION__"--. IRP %p STATUS %x", Irp, status);

    return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  SerialCloneWriteDispatch
//      Dispatch routine to handle IRP_MJ_WRITE
//
//  Arguments:
//      IN  DeviceObject
//              pointer to our device object
//
//      IN  Irp
//              pointer to the IRP_MJ_WRITE IRP
//
//  Return Value:
//      NT status code
//
NTSTATUS SerialCloneWriteDispatch(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
{
    PSERIALCLONE_DEVICE_EXTENSION    deviceExtension;
    NTSTATUS                        status;

    deviceExtension = (PSERIALCLONE_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
	    // Make sure we can accept IRPs
    if (!SerialCloneAcquireRemoveLock(deviceExtension))
    {
        status = STATUS_DELETE_PENDING;

        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);

        SerialCloneDebugPrint(DBG_GENERAL, DBG_WARN, __FUNCTION__"--. IRP %p STATUS %x", Irp, status);

        return status;
    }

	if(deviceExtension->Owner==deviceExtension->TypeFlag)
	{
		// we are in control
		IoSkipCurrentIrpStackLocation(Irp);
		status = IoCallDriver(deviceExtension->LowerDeviceObject, Irp);

	}
	else
	{
        status = STATUS_ACCESS_DENIED;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
	}

    SerialCloneReleaseRemoveLock(deviceExtension);
    SerialCloneDebugPrint(DBG_GENERAL, DBG_TRACE, __FUNCTION__"--. IRP %p STATUS %x", Irp, status);

    return status;

}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  SerialCloneDeviceIoControlDispatch
//      Dispatch routine to handle IRP_MJ_DEVICE_CONTROL
//
//  Arguments:
//      IN  DeviceObject
//              pointer to our device object
//
//      IN  Irp
//              pointer to the IRP_MJ_DEVICE_CONTROL IRP
//
//		Notes: This will look at the Device extension to determine which device contols the 
//             Device IO. The first device to do the create gets the control., Control is 
//             to the other device upon a close. 
//
//  Return Value:
//      NT status code
//
NTSTATUS SerialCloneDeviceIoControlDispatch(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
{
    PSERIALCLONE_DEVICE_EXTENSION    deviceExtension;
    NTSTATUS                        status;
    deviceExtension = (PSERIALCLONE_DEVICE_EXTENSION)DeviceObject->DeviceExtension;

    if(deviceExtension->TypeFlag == ISCLONE)
		return(CloneDeviceIoControlDispatch(DeviceObject,Irp));
	else if(deviceExtension->TypeFlag == ISFILTER)
		return(FilterDeviceIoControlDispatch(DeviceObject,Irp));
	else
		return STATUS_NOT_IMPLEMENTED;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  SerialCloneInternalDeviceIoControlDispatch
//      Dispatch routine to handle IRP_MJ_INTERNAL_DEVICE_CONTROL
//
//  Arguments:
//      IN  DeviceObject
//              pointer to our device object
//
//      IN  Irp
//              pointer to the IRP_MJ_INTERNAL_DEVICE_CONTROL IRP
//
//  Return Value:
//      NT status code
//
NTSTATUS SerialCloneInternalDeviceIoControlDispatch(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
{
    PSERIALCLONE_DEVICE_EXTENSION    deviceExtension;
    NTSTATUS                        status;

    deviceExtension = (PSERIALCLONE_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    if(deviceExtension->TypeFlag == ISCLONE)
		return(CloneInternalDeviceIoControlDispatch(DeviceObject,Irp));
	else if(deviceExtension->TypeFlag == ISFILTER)
		return(FilterInternalDeviceIoControlDispatch(DeviceObject,Irp));
	else
		return STATUS_NOT_IMPLEMENTED;

}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  SerialCloneSubmitIrpSyncComplete
//      Completion routine for sync IRP requests.
//
//  Arguments:
//      IN  DeviceObject
//              pointer to our device object
//
//      IN  Irp
//              pointer to the PnP IRP
//
//      IN  Context
//              our event used to signal IRP completion
//
//  Return Value:
//      STATUS_MORE_PROCESSING_REQUIRED
//
NTSTATUS  SerialCloneSubmitIrpSyncComplete(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    )
{
    PKEVENT event = (PKEVENT)Context;


    // If the lower driver didn't return STATUS_PENDING, we don't need to 
    // set the event because we won't be waiting on it. 
    if (Irp->PendingReturned) 
    {
        KeSetEvent(event, IO_NO_INCREMENT, FALSE);
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  SerialCloneSubmitIrpSync
//      Sends the given IRP down the stack to the next lower driver and 
//      waits in a synchronous fashion for the IRP to complete
//
//  Arguments:
//      IN  DeviceObject
//              Pointer to device object for our device
//
//      IN  Irp
//              IRP to send down
//
//  Return Value:
//      NT status code
//
NTSTATUS SerialCloneSubmitIrpSync(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
{
    KEVENT   event;
    NTSTATUS status;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(
        Irp,
        SerialCloneSubmitIrpSyncComplete,
        &event,
        TRUE,
        TRUE,
        TRUE
        );

    status = IoCallDriver(DeviceObject, Irp);

    // Wait for lower drivers to be done with the Irp.
    // Important thing to note here is when you allocate
    // memory for an event in the stack you must do a
    // KernelMode wait instead of UserMode to prevent
    // the stack from getting paged out.

    if (status == STATUS_PENDING) 
    {
       KeWaitForSingleObject(
           &event,
           Executive,
           KernelMode,
           FALSE,
           NULL
           );

       status = Irp->IoStatus.Status;
    }

    return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  SerialCloneAcquireRemoveLock
//      Acquires remove lock.
//
//  Arguments:
//      IN  DeviceExtension
//              our device extension
//
//  Return Value:
//      FALSE if remove device pending, TRUE otherwise.
//
BOOLEAN SerialCloneAcquireRemoveLock(
    IN  PSERIALCLONE_DEVICE_EXTENSION    DeviceExtension
    )
{
    InterlockedIncrement(&DeviceExtension->RemoveCount);
    if (PnpStateRemoved == DeviceExtension->PnpState)
    {
        SerialCloneReleaseRemoveLock(DeviceExtension);

        return FALSE;
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  SerialCloneReleaseRemoveLock
//      Releases remove lock.
//
//  Arguments:
//      IN  DeviceExtension
//              our device extension
//
//  Return Value:
//      None.
//
VOID SerialCloneReleaseRemoveLock(
    IN  PSERIALCLONE_DEVICE_EXTENSION    DeviceExtension
    )
{
    if (InterlockedDecrement(&DeviceExtension->RemoveCount) == 0)
    {
        KeSetEvent(&DeviceExtension->RemoveEvent, IO_NO_INCREMENT, FALSE);
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  SerialCloneWaitForSafeRemove
//      Waits for all remove locks to be released
//
//  Arguments:
//      IN  DeviceExtension
//              our device extension
//
//  Return Value:
//      None.
//
//  Comment:
//      This routine should be called with no remove locks held 
//      by the calling thread
//
VOID SerialCloneWaitForSafeRemove(
    IN  PSERIALCLONE_DEVICE_EXTENSION    DeviceExtension
    )
{
    DeviceExtension->PnpState = PnpStateRemoved;
    SerialCloneReleaseRemoveLock(DeviceExtension);

    KeWaitForSingleObject(
        &DeviceExtension->RemoveEvent, 
        Executive, 
        KernelMode, 
        FALSE, 
        NULL
        );
}
///////////////////////////////////////////////////////////////////////////////////////////////////
//  vportSerialReadSymName
//      reads symbolic link name for serial device
//
//  Arguments:
//      IN  DeviceExtension
//              our device extension
//
//      IN  Handle
//              handle to device (hardware) key
//
//      OUT SymbolicLinkName
//              link name
//
//      OUT RegName
//              port name from registry
//
//  Return Value:
//      status
//
NTSTATUS SerialCloneSerialReadSymName(
    IN  PSERIALCLONE_DEVICE_EXTENSION       DeviceExtension, 
    IN  HANDLE                      Handle,
    OUT PUNICODE_STRING             SymbolicLinkName, 
    OUT PWCHAR*                     RegName
    )
{
    UNICODE_STRING  linkName;
    ULONG           length;

    *RegName = NULL;

    RtlZeroMemory(&linkName, sizeof(UNICODE_STRING));

    // allocate memory for symbolic link
    linkName.MaximumLength = 256*sizeof(WCHAR);
    linkName.Buffer = (PWCHAR)ExAllocatePool(PagedPool, linkName.MaximumLength + sizeof(UNICODE_NULL));
    if (linkName.Buffer == NULL) 
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(linkName.Buffer, linkName.MaximumLength + sizeof(UNICODE_NULL));

    // read port name out of registry
    *RegName = (PWCHAR)SerialCloneRegQueryValueKey(Handle, NULL, L"PortName", &length);
    if (*RegName == NULL)
    {
        // try alternative location
        *RegName = (PWCHAR)SerialCloneRegQueryValueKey(Handle, NULL, L"Identifier", &length);
    }

    // something is not right here
    if (*RegName == NULL) 
    {
        ExFreePool(linkName.Buffer);
        linkName.Buffer = NULL;

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Create the "\\??\\<symbolicName>" string
    RtlAppendUnicodeToString(&linkName, L"\\??\\");
    RtlAppendUnicodeToString(&linkName, *RegName);
    RtlAppendUnicodeToString(&linkName, L"0");

    // allocate symbolic link
    SymbolicLinkName->MaximumLength = linkName.Length + sizeof(UNICODE_NULL);
    SymbolicLinkName->Buffer = (PWCHAR)ExAllocatePool(PagedPool, SymbolicLinkName->MaximumLength);
    if (SymbolicLinkName->Buffer == NULL) 
    {
        ExFreePool(linkName.Buffer);
        linkName.Buffer = NULL;

        ExFreePool(*RegName);
        *RegName = NULL;

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // copy symbolic link
    RtlZeroMemory(SymbolicLinkName->Buffer, SymbolicLinkName->MaximumLength);
    RtlAppendUnicodeStringToString(SymbolicLinkName, &linkName);

    if (linkName.Buffer != NULL) 
    {
        ExFreePool(linkName.Buffer);
        linkName.Buffer = NULL;
    }

    return STATUS_SUCCESS;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  SerialCloneCreateComName
//      creates win32 visible device name
//
//  Arguments:
//      IN  DeviceExtension
//              our device extension
//
//  Return Value:
//      status
//
NTSTATUS SerialCloneCreateComName(
    IN  PSERIALCLONE_DEVICE_EXTENSION   DeviceExtension
    )
{
    NTSTATUS        status;
    HANDLE          keyHandle;
    UNICODE_STRING  linkName;
    PWCHAR          regName;
    ULONG           length;
    BOOLEAN         createdLink;
    BOOLEAN         createdCommEntry;
    UNICODE_STRING  dosName;

    // open device hardware key
    status = IoOpenDeviceRegistryKey(DeviceExtension->PhysicalDeviceObject, PLUGPLAY_REGKEY_DEVICE, STANDARD_RIGHTS_READ, &keyHandle);  
    if (!NT_SUCCESS(status))
    {
        return status;
    }

    RtlZeroMemory(&linkName, sizeof(UNICODE_STRING));
    RtlZeroMemory(&dosName, sizeof(UNICODE_STRING));

    // get our device object symbolic link name
    status = SerialCloneSerialReadSymName(DeviceExtension, keyHandle, &linkName, &regName);
    ZwClose(keyHandle);

    if (!NT_SUCCESS(status))
    {
        return status;
    }

    createdLink = FALSE;
    createdCommEntry = FALSE;

    do
    {
        // allocate memory for wmi name
        //length = wcslen(regName)*sizeof(WCHAR) + sizeof(UNICODE_NULL);
        //DeviceExtension->WmiIdentifier.Buffer = (PWCHAR)ExAllocatePool(PagedPool, length);
        //if (DeviceExtension->WmiIdentifier.Buffer == NULL) 
        //{
        //    status = STATUS_INSUFFICIENT_RESOURCES;
        //    break;
        //}

        //RtlZeroMemory(DeviceExtension->WmiIdentifier.Buffer, length);

        // copy device object name to wmi name
        //DeviceExtension->WmiIdentifier.Length = 0;
        //DeviceExtension->WmiIdentifier.MaximumLength = (USHORT)length - sizeof(UNICODE_NULL);
        //RtlAppendUnicodeToString(&DeviceExtension->WmiIdentifier, regName);

        // create a symbolic link 
        status = IoCreateSymbolicLink(&linkName, &DeviceExtension->ntDeviceName);
        if (!NT_SUCCESS(status))
        {
            break;
        }

        createdLink = TRUE;

        // init dos name string
        RtlInitUnicodeString(&dosName, regName);
	    RtlAppendUnicodeToString(&dosName, L"0");

        // save symbolic link mapping in registry
        status = RtlWriteRegistryValue(
                    RTL_REGISTRY_DEVICEMAP, 
                    L"SERIALCOMM",
                    DeviceExtension->ntDeviceName.Buffer, 
                    REG_SZ,
                    dosName.Buffer,
                    dosName.Length + sizeof(WCHAR)
                    );

        if (!NT_SUCCESS(status)) 
        {
            break;
        }

        createdCommEntry = TRUE;

        // register device interface
        status = IoRegisterDeviceInterface(
                    DeviceExtension->PhysicalDeviceObject, 
                    (LPGUID)&GUID_CLASS_COMPORT, 
                    NULL, 
                    &DeviceExtension->InterfaceName
                    );

        if (!NT_SUCCESS(status)) 
        {
            DeviceExtension->InterfaceName.Buffer = NULL;
            break;
        }


        status = IoSetDeviceInterfaceState(&DeviceExtension->InterfaceName, TRUE);
    }
    while (FALSE);

    // in case of failure we need to unwind all the allocated resources
    if (!NT_SUCCESS(status))
    {
        // free memory allocated for device interface name by
        // IoRegisterDeviceInterface call
        if (DeviceExtension->InterfaceName.Buffer) 
        {
            IoSetDeviceInterfaceState(&DeviceExtension->InterfaceName, FALSE);
            ExFreePool(DeviceExtension->InterfaceName.Buffer);
            DeviceExtension->InterfaceName.Buffer = NULL;
        }

        // undo RtlWriteRegistryValue call
        if (createdCommEntry) 
        {
            RtlDeleteRegistryValue(RTL_REGISTRY_DEVICEMAP, L"SERIALCOMM", DeviceExtension->ntDeviceName.Buffer);
        }

        // undo IoCreateSymbolicLink call
        if (createdLink ==  TRUE) 
        {
            IoDeleteSymbolicLink(&linkName);
        }

        // free wmi id name buffer
        //if (DeviceExtension->WmiIdentifier.Buffer != NULL) 
        //{
        //    ExFreePool(DeviceExtension->WmiIdentifier.Buffer);
        //    DeviceExtension->WmiIdentifier.Buffer = NULL;
        //}
    }

    // free resources allocated by SerialCloneSerialReadSymName call
    if (regName != NULL) 
    {
        ExFreePool(regName);
    }

    if (linkName.Buffer != NULL) 
    {
        ExFreePool(linkName.Buffer);
    }

    return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  SerialCloneDeleteComName
//      deletes win32 visible device name
//
//  Arguments:
//      IN  DeviceExtension
//              our device extension
//
//  Return Value:
//      status
//
NTSTATUS SerialCloneDeleteComName(
    IN  PSERIALCLONE_DEVICE_EXTENSION   DeviceExtension
    )
{
    NTSTATUS        status;
    HANDLE          keyHandle;
    UNICODE_STRING  linkName;
    PWCHAR          regName;

    // undo device interface registration 
    if (DeviceExtension->InterfaceName.Buffer) 
    {
        status = IoSetDeviceInterfaceState(&DeviceExtension->InterfaceName, FALSE);

        ExFreePool(DeviceExtension->InterfaceName.Buffer);
        DeviceExtension->InterfaceName.Buffer = NULL;
    }

    // delete symbolic link map
    status = RtlDeleteRegistryValue(RTL_REGISTRY_DEVICEMAP, L"SERIALCOMM", DeviceExtension->ntDeviceName.Buffer);

    // delete symbolic link itself
    status = IoOpenDeviceRegistryKey(DeviceExtension->PhysicalDeviceObject, PLUGPLAY_REGKEY_DEVICE, STANDARD_RIGHTS_READ, &keyHandle);
    if (NT_SUCCESS(status)) 
    {
        RtlInitUnicodeString(&linkName, NULL);

        status = SerialCloneSerialReadSymName(DeviceExtension, keyHandle, &linkName, &regName);
        if (NT_SUCCESS(status)) 
        {
            IoDeleteSymbolicLink(&linkName);

            ExFreePool(linkName.Buffer);
            ExFreePool(regName);
        }

        ZwClose(keyHandle);
    }

    // free wmi id name buffer
    //if (DeviceExtension->WmiIdentifier.Buffer) 
    //{
    //    ExFreePool(DeviceExtension->WmiIdentifier.Buffer);
    //    DeviceExtension->WmiIdentifier.MaximumLength = DeviceExtension->WmiIdentifier.Length = 0;
    //    DeviceExtension->WmiIdentifier.Buffer = NULL;
   // }

    return status;
}

NTSTATUS ForwardAndWait(IN PDEVICE_OBJECT fdo, IN PIRP Irp)
	{							// ForwardAndWait
	KEVENT event;
	PSERIALCLONE_DEVICE_EXTENSION pdx ;
	ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
	PAGED_CODE();
	
	KeInitializeEvent(&event, NotificationEvent, FALSE);

	IoCopyCurrentIrpStackLocationToNext(Irp);
	IoSetCompletionRoutine(Irp, (PIO_COMPLETION_ROUTINE) OnRequestComplete,
		(PVOID) &event, TRUE, TRUE, TRUE);

	pdx = (PSERIALCLONE_DEVICE_EXTENSION) fdo->DeviceExtension;
	IoCallDriver(pdx->LowerDeviceObject, Irp);
	KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
	return Irp->IoStatus.Status;
	}							// ForwardAndWait


#pragma LOCKEDCODE

NTSTATUS OnRequestComplete(IN PDEVICE_OBJECT fdo, IN PIRP Irp, IN PKEVENT pev)
	{							// OnRequestComplete
	KeSetEvent(pev, 0, FALSE);
	return STATUS_MORE_PROCESSING_REQUIRED;
	}							// OnRequestComplete

NTSTATUS CompleteRequest(IN PIRP Irp, IN NTSTATUS status, IN ULONG_PTR info)
	{							// CompleteRequest
	Irp->IoStatus.Status = status;
	Irp->IoStatus.Information = info;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return status;
	}							// CompleteRequest

//NTSTATUS CompleteRequest(IN PIRP Irp, IN NTSTATUS status)
//	{							// CompleteRequest
//	Irp->IoStatus.Status = status;
//	IoCompleteRequest(Irp, IO_NO_INCREMENT);
//	return status;
//	}							// CompleteRequest

static NTSTATUS OnRepeaterComplete(PDEVICE_OBJECT tdo, PIRP subirp, PVOID needsvote)
{							// OnRepeaterComplete
	PIO_STACK_LOCATION substack;
	PIRP Irp;
	ObDereferenceObject(tdo);
	substack = IoGetCurrentIrpStackLocation(subirp);
	Irp = (PIRP) substack->Parameters.Others.Argument1;

	// Complete the main IRP. We need to copy IoStatus.Information from the
	// now-complete repeater IRP, inasmuch as it contains the "return value"
	// from the IRP. If the repeater IRP still holds STATUS_NOT_SUPPORTED as
	// its status, the parent device stack didn't actually process the IRP.
	// The status we then set depends on the "needsvote" value developed by
	// RepeatRequest.

	if (subirp->IoStatus.Status == STATUS_NOT_SUPPORTED)
		{						// parent stack ignored this IRP
		if (needsvote)
			Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
		}						// parent stack ignored this IRP
	else
		Irp->IoStatus = subirp->IoStatus; // propagate status from parent stack

	Irp->IoStatus.Information = subirp->IoStatus.Information;

	IoFreeIrp(subirp);
	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	return STATUS_MORE_PROCESSING_REQUIRED;
	}							// OnRepeaterComplete

///////////////////////////////////////////////////////////////////////////////

#pragma PAGEDCODE

NTSTATUS FailRequest(PDEVICE_OBJECT pdo, PIRP Irp,NTSTATUS err)
	{							// SucceedRequest
	Irp->IoStatus.Status = err;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return err;
	}							// SucceedRequest

NTSTATUS SucceedRequest(PDEVICE_OBJECT pdo, PIRP Irp)
	{							// SucceedRequest
	Irp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
	}							// SucceedRequest


NTSTATUS IgnoreRequest(PDEVICE_OBJECT pdo, PIRP Irp)
	{							// IgnoreRequest
	NTSTATUS status = Irp->IoStatus.Status;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return status;
	}							// IgnoreRequest

NTSTATUS RepeatRequest(PDEVICE_OBJECT pdo, PIRP Irp)
	{							// RepeatRequest
	PSERIALCLONE_DEVICE_EXTENSION pdx;
	PDEVICE_OBJECT fdo;
	PSERIALCLONE_DEVICE_EXTENSION pfx;
	PIO_STACK_LOCATION stack;

	PDEVICE_OBJECT tdo;
	PIRP subirp;
	PIO_STACK_LOCATION substack;

	pdx = (PSERIALCLONE_DEVICE_EXTENSION) pdo->DeviceExtension;
	fdo = pdx->FDeviceObject;
	pfx = (PSERIALCLONE_DEVICE_EXTENSION) fdo->DeviceExtension;
	stack =IoGetCurrentIrpStackLocation(Irp);
	tdo  = IoGetAttachedDeviceReference(fdo);
	subirp  = IoAllocateIrp(tdo->StackSize + 1, FALSE);
	
	if (!subirp)
		return CompleteRequest(Irp, STATUS_INSUFFICIENT_RESOURCES, Irp->IoStatus.Information);

	// Setup extra stack location at the top so we can cleanup and complete
	// the main IRP

	substack = IoGetNextIrpStackLocation(subirp);
	substack->DeviceObject = tdo;
	substack->Parameters.Others.Argument1 = (PVOID) Irp;

	// Setup next stack location for the FDO stack to process the repeater IRP

	IoSetNextIrpStackLocation(subirp);
	substack = IoGetNextIrpStackLocation(subirp);
	RtlCopyMemory(substack, stack, FIELD_OFFSET(IO_STACK_LOCATION, CompletionRoutine));
	substack->Control = 0;

	// Our completion routine needs a way to know what to do if the parent driver stack
	// completes the subsidiary IRP with STATUS_NOT_SUPPORTED. For some IRPs (ones that
	// require a parental "vote" on their status), we want to fail the IRPs if no-one
	// in the parent stack handles it. For others, we don't want to change the status
	// passed down to us from the child stack. Since we're not using the context
	// argument for any other purpose in our completion routine, we pass a simple
	// boolean value to distinguish the two cases.
	{
		UCHAR subfunc; 
		BOOLEAN needsvote;
		static BOOLEAN voteflag[] = {
			FALSE,			// IRP_MN_START_DEVICE [don't care since not repeated]
			FALSE,			// IRP_MN_QUERY_REMOVE_DEVICE [don't care since not repeated]
			FALSE,			// IRP_MN_REMOVE_DEVICE [don't care since not repeated]
			FALSE,			// IRP_MN_CANCEL_REMOVE_DEVICE [don't care since not repeated]
			FALSE,			// IRP_MN_STOP_DEVICE [don't care since not repeated]
			FALSE,			// IRP_MN_QUERY_STOP_DEVICE [don't care since not repeated]
			FALSE,			// IRP_MN_CANCEL_STOP_DEVICE [don't care since not repeated]
			FALSE,			// IRP_MN_QUERY_DEVICE_RELATIONS [don't care since not repeated]
			FALSE,			// IRP_MN_QUERY_INTERFACE
			FALSE,			// IRP_MN_QUERY_CAPABILITIES
			FALSE,			// IRP_MN_QUERY_RESOURCES [don't care since not repeated]
			FALSE,			// IRP_MN_QUERY_RESOURCE_REQUIREMENTS [don't care since not repeated]
			FALSE,			// IRP_MN_QUERY_DEVICE_TEXT [don't care since not repeated]
			FALSE,			// IRP_MN_FILTER_RESOURCE_REQUIREMENTS [don't care since not repeated]
			FALSE,			//  [don't care since not repeated]
			TRUE,			// IRP_MN_READ_CONFIG
			TRUE,			// IRP_MN_WRITE_CONFIG
			TRUE,			// IRP_MN_EJECT [no-one above us should have changed status anyway]
			TRUE,			// IRP_MN_SET_LOCK [no-one above us should have changed status anyway]
			FALSE,			// IRP_MN_QUERY_ID [don't care since not repeated]
			FALSE,			// IRP_MN_QUERY_PNP_DEVICE_STATE
			TRUE,			// IRP_MN_QUERY_BUS_INFORMATION
			FALSE,			// IRP_MN_DEVICE_USAGE_NOTIFICATION
 			FALSE,			// IRP_MN_SURPRISE_REMOVAL [don't care since not repeated]
			TRUE,			// IRP_MN_QUERY_LEGACY_BUS_INFORMATION
			};

		subfunc= stack->MinorFunction;
		needsvote= subfunc < arraysize(voteflag) ? voteflag[subfunc] : TRUE;
		IoSetCompletionRoutine(subirp, (PIO_COMPLETION_ROUTINE) OnRepeaterComplete, (PVOID) needsvote, TRUE, TRUE, TRUE);

		// Initialize completion status for the repeater IRP to STATUS_NOT_SUPPORTED.
		// This is required to avoid a bug check in the driver verifier. The underlying
		// reason is that some drivers in some parent stacks (not MULFUNC's, because it's
		// not a real device, but in general) need a way to know when someone truly handles
		// this IRP.
	}
	subirp->IoStatus.Status = STATUS_NOT_SUPPORTED;

	// Return STATUS_PENDING because we won't know until completion time what the
	// right status is (and it may not be what the parent stack returns here).

	IoMarkIrpPending(Irp);
	IoCallDriver(tdo, subirp);
	return STATUS_PENDING;
	}							// RepeatRequest


void SCFifoInit(PSCFIFO  fifo, char * buffer, ULONG size)
{
	fifo->Buffer=buffer;
	fifo->BuffSize=size;
	fifo->End = buffer+size;
	fifo->In = buffer;
	fifo->Out = buffer;
	fifo->Size=0;
}



NTSTATUS SCFifoRead(PSCFIFO  fifo, char * dest, ULONG size,ULONG * rsltSize)
{
	ULONG rdSize;


	rdSize = (size<fifo->Size) ? size : fifo->Size;

	if(fifo->Out + rdSize < fifo->End) // no wrap
	{
		RtlCopyMemory(dest,fifo->Out,rdSize);
		fifo->Out+=rdSize;
		fifo->Size-=rdSize;
	}
	else // wrap
	{
		ULONG spacebeforwrap = fifo->End - fifo->Out;
		RtlCopyMemory(dest,fifo->Out,spacebeforwrap);
		RtlCopyMemory(dest+spacebeforwrap,fifo->Buffer,rdSize-spacebeforwrap);
		fifo->Out=fifo->Buffer+rdSize-spacebeforwrap;
		fifo->Size-=rdSize;
	}
	*rsltSize=rdSize;
	return 0;
}
NTSTATUS SCFifoWrite(PSCFIFO  fifo, char * src, ULONG size)
{

	if(fifo->BuffSize <size) // we will overflow the buffer!
	{
		char * strt = src + (size-fifo->BuffSize);
		RtlCopyMemory(fifo->Buffer,strt,fifo->BuffSize);
		fifo->Size=fifo->BuffSize;
		fifo->In=fifo->Buffer;
		fifo->Out = fifo->Buffer;
	}
	else
	{
		ULONG spacebeforwrap = fifo->End - fifo->In;
		if(spacebeforwrap<size)
		{
			RtlCopyMemory(fifo->In,src,spacebeforwrap);
			RtlCopyMemory(fifo->Buffer,src+spacebeforwrap,size-spacebeforwrap);
			fifo->In=fifo->Buffer+size-spacebeforwrap+1;
		}
		else
		{
			RtlCopyMemory(fifo->In,src,size);
			fifo->In+=size;
		}
		if(fifo->BuffSize<size+fifo->Size)
		{   // we over flowed
			fifo->Size= fifo->BuffSize;
			fifo->Out=fifo->In;
		}
		else fifo->Size+=size;
	}

	return 0;
}

ULONG GetPendingSize(LIST_ENTRY * list)
{
	ULONG size = 0;
	PSERIALCLONE_IRP_STATUS IrpStat;
	PLIST_ENTRY curr;
	curr = list;
	if(IsListEmpty(list))
	 return 0;
	while(curr = curr->Flink)
	{
		if(curr==curr->Flink) break;
		if(curr==list) break;
		IrpStat = CONTAINING_RECORD(curr,SERIALCLONE_IRP_STATUS,link); 
		size+=IrpStat->Size;
	}
	return size;
}


////////
///////////////////////////////////////////////////////////////////////////////

